{"version":3,"file":"index.js","mappings":"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","sources":["webpack:///./src/distorted-tv.ts","webpack:///./src/filter-stream.ts","webpack:///./src/media-devices.ts","webpack:///./src/shader-renderer.ts","webpack:///webpack/bootstrap","webpack:///./src/index.ts"],"sourcesContent":["// \"Distorted TV\" by ehj1 https://shadertoy.com/view/ldXGW4\n\nexport const distortedTV = `\n// change these values to 0.0 to turn off individual effects\nfloat vertJerkOpt = 1.0;\nfloat vertMovementOpt = 1.0;\nfloat bottomStaticOpt = 1.0;\nfloat scalinesOpt = 1.0;\nfloat rgbOffsetOpt = 1.0;\nfloat horzFuzzOpt = 1.0;\n\n// Noise generation functions borrowed from: \n// https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat staticV(vec2 uv) {\n    float staticHeight = snoise(vec2(9.0,iTime*1.2+3.0))*0.3+5.0;\n    float staticAmount = snoise(vec2(1.0,iTime*1.2-6.0))*0.1+0.3;\n    float staticStrength = snoise(vec2(-9.75,iTime*0.6-3.0))*2.0+2.0;\n\treturn (1.0-step(snoise(vec2(5.0*pow(iTime,2.0)+pow(uv.x*7.0,1.2),pow((mod(iTime,100.0)+100.0)*uv.y*0.3+3.0,staticHeight))),staticAmount))*staticStrength;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv =  fragCoord.xy/iResolution.xy;\n\t\n\tfloat jerkOffset = (1.0-step(snoise(vec2(iTime*1.3,5.0)),0.8))*0.05;\n\t\n\tfloat fuzzOffset = snoise(vec2(iTime*15.0,uv.y*80.0))*0.003;\n\tfloat largeFuzzOffset = snoise(vec2(iTime*1.0,uv.y*25.0))*0.004;\n    \n    float vertMovementOn = (1.0-step(snoise(vec2(iTime*0.2,8.0)),0.4))*vertMovementOpt;\n    float vertJerk = (1.0-step(snoise(vec2(iTime*1.5,5.0)),0.6))*vertJerkOpt;\n    float vertJerk2 = (1.0-step(snoise(vec2(iTime*5.5,5.0)),0.2))*vertJerkOpt;\n    float yOffset = abs(sin(iTime)*4.0)*vertMovementOn+vertJerk*vertJerk2*0.3;\n    float y = mod(uv.y+yOffset,1.0);\n    \n\t\n\tfloat xOffset = (fuzzOffset + largeFuzzOffset) * horzFuzzOpt;\n    \n    float staticVal = 0.0;\n   \n    for (float y = -1.0; y <= 1.0; y += 1.0) {\n        float maxDist = 5.0/200.0;\n        float dist = y/200.0;\n    \tstaticVal += staticV(vec2(uv.x,uv.y+dist))*(maxDist-abs(dist))*1.5;\n    }\n        \n    staticVal *= bottomStaticOpt;\n\t\n\tfloat red \t=   texture2D(\tiChannel0, \tvec2(uv.x + xOffset -0.01*rgbOffsetOpt,y)).r+staticVal;\n\tfloat green = \ttexture2D(\tiChannel0, \tvec2(uv.x + xOffset,\t  y)).g+staticVal;\n\tfloat blue \t=\ttexture2D(\tiChannel0, \tvec2(uv.x + xOffset +0.01*rgbOffsetOpt,y)).b+staticVal;\n\t\n\tvec3 color = vec3(red,green,blue);\n\tfloat scanline = sin(uv.y*800.0)*0.04*scalinesOpt;\n\tcolor -= scanline;\n\t\n\tfragColor = vec4(color,1.0);\n}\n`;\n","import {ShaderRenderer} from './shader-renderer';\n\nclass FilterStream {\n  video: HTMLVideoElement;\n  canvas: HTMLCanvasElement;\n  renderer: ShaderRenderer;\n  stream: MediaStream;\n  outputStream: MediaStream;\n\n  constructor(stream: MediaStream, shader: string) {\n    console.log('New Filter for stream', stream);\n    this.stream = stream;\n    const video = document.createElement('video');\n    const canvas = document.createElement('canvas');\n    this.canvas = canvas;\n    this.renderer = new ShaderRenderer(this.canvas, video, shader);\n\n    video.addEventListener('playing', () => {\n      // Use a 2D Canvas.\n      // this.canvas.width = this.video.videoWidth;\n      // this.canvas.height = this.video.videoHeight;\n\n      // Use a WebGL Renderer.\n      this.renderer.setSize(this.video.videoWidth, this.video.videoHeight);\n      this.update();\n    });\n    video.srcObject = stream;\n    video.autoplay = true;\n    this.video = video;\n    //this.ctx = this.canvas.getContext('2d');\n    this.outputStream = this.canvas.captureStream();\n  }\n\n  update() {\n    // Use a 2D Canvas\n    // this.ctx.filter = 'invert(1)';\n    // this.ctx.drawImage(this.video, 0, 0);\n    // this.ctx.fillStyle = '#ff00ff';\n    // this.ctx.textBaseline = 'top';\n    // this.ctx.fillText('Virtual', 10, 10)\n\n    // Use a WebGL renderer.\n    this.renderer.render();\n    requestAnimationFrame(() => this.update());\n  }\n}\n\nexport {FilterStream};\n","import {FilterStream} from './filter-stream';\n\n// Ideally we'd use an editor or import shaders directly from the API.\nimport {distortedTV as shader} from './distorted-tv';\n//import { moneyFilter as shader } from './money-filter.js';\n\nfunction monkeyPatchMediaDevices() {\n  const enumerateDevicesFn = MediaDevices.prototype.enumerateDevices;\n  const getUserMediaFn = MediaDevices.prototype.getUserMedia;\n\n  MediaDevices.prototype.enumerateDevices = async function () {\n    const res = await enumerateDevicesFn.call(navigator.mediaDevices);\n    // We could add \"Virtual VHS\" or \"Virtual Median Filter\" and map devices with filters.\n    res.push({\n      deviceId: 'virtual',\n      groupId: 'uh',\n      kind: 'videoinput',\n      label: 'Virtual Chrome Webcam',\n    } as MediaDeviceInfo);\n    return res;\n  };\n\n  MediaDevices.prototype.getUserMedia = async function (...args) {\n    console.log(args[0]);\n    const constraints = args[0] as MediaStreamConstraints;\n    if (\n      args.length &&\n      constraints.video &&\n      (constraints.video as MediaTrackConstraints).deviceId\n    ) {\n      if ((constraints.video as MediaTrackConstraints).deviceId === 'virtual') {\n        // This constraints could mimick closely the request.\n        // Also, there could be a preferred webcam on the options.\n        // Right now it defaults to the predefined input.\n        const constraints2: MediaStreamConstraints = {\n          video: {\n            facingMode: (constraints.video as MediaTrackConstraints).facingMode,\n            advanced: (constraints.video as MediaTrackConstraints).advanced,\n            width: (constraints.video as MediaTrackConstraints).width,\n            height: (constraints.video as MediaTrackConstraints).height,\n          },\n          audio: false,\n        };\n        const res = await getUserMediaFn.call(\n          navigator.mediaDevices,\n          constraints2\n        );\n        if (res) {\n          const filter = new FilterStream(res, shader);\n          return filter.outputStream;\n        }\n      }\n    }\n    const res = await getUserMediaFn.call(navigator.mediaDevices, ...args);\n    return res;\n  };\n\n  console.log('VIRTUAL WEBCAM INSTALLED.');\n}\n\nexport {monkeyPatchMediaDevices};\n","const vs = `\n  attribute vec4 a_position;\n\n  void main() {\n    gl_Position = a_position;\n  }\n`;\n\nconst fs = `\nprecision highp float;\n\nuniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform float iTime;\n\n  void main() {\n    vec2 uv = gl_FragCoord.xy / iResolution;\n    vec4 cam = texture2D(iChannel0, uv);\n    gl_FragColor = vec4(cam.r, uv, 1.);\n  }\n`;\n\nfunction wrapShaderToy(source: string) {\n  return `\n\nprecision highp float;\n\nuniform vec2 iResolution;\nuniform sampler2D iChannel0;\nuniform float iTime;\n\n${source}\n\nvoid main() {\n  vec4 col;\n  mainImage(col, gl_FragCoord.xy);\n  gl_FragColor = col;\n}\n`;\n}\n\nclass ShaderRenderer {\n  canvas: HTMLCanvasElement;\n  gl: WebGLRenderingContext;\n  video: HTMLVideoElement;\n  texture: WebGLTexture;\n  program: WebGLProgram;\n  timeLocation: WebGLUniformLocation;\n  resolutionLocation: WebGLUniformLocation;\n  cameraLocation: WebGLUniformLocation;\n  positionBuffer: WebGLBuffer;\n  positionAttributeLocation: number;\n\n  constructor(\n    canvas: HTMLCanvasElement,\n    video: HTMLVideoElement,\n    shader: string\n  ) {\n    this.canvas = canvas;\n    this.video = video;\n\n    this.gl = this.canvas.getContext('webgl')!;\n    //this.gl.getExtension('EXT_shader_texture_lod');\n\n    this.program = this.createProgram(vs, wrapShaderToy(shader));\n\n    this.texture = this.gl.createTexture()!;\n\n    this.positionAttributeLocation = this.gl.getAttribLocation(\n      this.program,\n      'a_position'\n    );\n    this.positionBuffer = this.gl.createBuffer()!;\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n    this.gl.bufferData(\n      this.gl.ARRAY_BUFFER,\n      new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]),\n      this.gl.STATIC_DRAW\n    );\n    this.resolutionLocation = this.gl.getUniformLocation(\n      this.program,\n      'iResolution'\n    )!;\n    this.cameraLocation = this.gl.getUniformLocation(\n      this.program,\n      'iChannel0'\n    )!;\n    this.timeLocation = this.gl.getUniformLocation(this.program, 'iTime')!;\n  }\n\n  createShader(sourceCode: string, type: number): WebGLShader {\n    const shader = this.gl.createShader(type)!;\n    this.gl.shaderSource(shader, sourceCode);\n    this.gl.compileShader(shader);\n\n    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n      const info = this.gl.getShaderInfoLog(shader);\n      console.log(info);\n      // debugger;\n      throw 'Could not compile WebGL program. \\n\\n' + info;\n    }\n    return shader;\n  }\n\n  createProgram(\n    vertexShaderSource: string,\n    fragmentShaderSource: string\n  ): WebGLProgram {\n    const vertexShader = this.createShader(\n      vertexShaderSource,\n      this.gl.VERTEX_SHADER\n    );\n    const fragmentShader = this.createShader(\n      fragmentShaderSource,\n      this.gl.FRAGMENT_SHADER\n    );\n\n    const program = this.gl.createProgram()!;\n    this.gl.attachShader(program, vertexShader);\n    this.gl.attachShader(program, fragmentShader);\n    this.gl.linkProgram(program);\n    const success = this.gl.getProgramParameter(program, this.gl.LINK_STATUS);\n    // if (success) {\n    return program;\n    // }\n    // console.log(this.gl.getProgramInfoLog(program));\n    // this.gl.deleteProgram(program);\n  }\n\n  setSize(w: number, h: number) {\n    this.canvas.width = w;\n    this.canvas.height = h;\n    this.gl.viewport(0, 0, w, h);\n  }\n\n  render() {\n    //this.gl.clearColor(255, 0, 255, 1);\n    //this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, true);\n    this.gl.texImage2D(\n      this.gl.TEXTURE_2D,\n      0,\n      this.gl.RGBA,\n      this.gl.RGBA,\n      this.gl.UNSIGNED_BYTE,\n      this.video\n    );\n    this.gl.texParameteri(\n      this.gl.TEXTURE_2D,\n      this.gl.TEXTURE_MAG_FILTER,\n      this.gl.LINEAR\n    );\n    this.gl.texParameteri(\n      this.gl.TEXTURE_2D,\n      this.gl.TEXTURE_MIN_FILTER,\n      this.gl.LINEAR\n    );\n    this.gl.texParameteri(\n      this.gl.TEXTURE_2D,\n      this.gl.TEXTURE_WRAP_S,\n      this.gl.CLAMP_TO_EDGE\n    );\n    this.gl.texParameteri(\n      this.gl.TEXTURE_2D,\n      this.gl.TEXTURE_WRAP_T,\n      this.gl.CLAMP_TO_EDGE\n    );\n    this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n\n    this.gl.useProgram(this.program);\n    this.gl.uniform2f(\n      this.resolutionLocation,\n      this.gl.canvas.width,\n      this.gl.canvas.height\n    );\n    if (this.timeLocation) {\n      this.gl.uniform1f(this.timeLocation, 0.001 * performance.now());\n    }\n\n    this.gl.activeTexture(this.gl.TEXTURE0);\n    this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n    this.gl.uniform1i(this.cameraLocation, 0);\n\n    this.gl.enableVertexAttribArray(this.positionAttributeLocation);\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n    this.gl.vertexAttribPointer(\n      this.positionAttributeLocation,\n      2,\n      this.gl.FLOAT,\n      false,\n      0,\n      0\n    );\n\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n  }\n}\n\nexport {ShaderRenderer};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {monkeyPatchMediaDevices} from './media-devices';\n\nmonkeyPatchMediaDevices();\n\nasync function init() {\n  const res = await navigator.mediaDevices.enumerateDevices();\n  console.log(res);\n  const stream = await navigator.mediaDevices.getUserMedia({\n    video: {deviceId: 'virtual'},\n    audio: false,\n  });\n  const video = document.createElement('video');\n  video.srcObject = stream;\n  video.autoplay = true;\n  document.body.append(video);\n}\n\ninit();\n"],"names":["distortedTV","FilterStream","constructor","stream","shader","console","log","this","video","document","createElement","canvas","renderer","ShaderRenderer","addEventListener","setSize","videoWidth","videoHeight","update","srcObject","autoplay","outputStream","captureStream","render","requestAnimationFrame","monkeyPatchMediaDevices","enumerateDevicesFn","MediaDevices","prototype","enumerateDevices","getUserMediaFn","getUserMedia","async","res","call","navigator","mediaDevices","push","deviceId","groupId","kind","label","args","constraints","length","constraints2","facingMode","advanced","width","height","audio","gl","getContext","program","createProgram","texture","createTexture","positionAttributeLocation","getAttribLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","resolutionLocation","getUniformLocation","cameraLocation","timeLocation","createShader","sourceCode","type","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","info","getShaderInfoLog","vertexShaderSource","fragmentShaderSource","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","attachShader","linkProgram","getProgramParameter","LINK_STATUS","w","h","viewport","bindTexture","TEXTURE_2D","pixelStorei","UNPACK_FLIP_Y_WEBGL","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","useProgram","uniform2f","uniform1f","performance","now","activeTexture","TEXTURE0","uniform1i","enableVertexAttribArray","vertexAttribPointer","FLOAT","drawArrays","TRIANGLES","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","body","append","init"],"sourceRoot":""}